>[!NOTE] 对象生命周期和资源管理
>因为 `C++` 没有[[#垃圾自动回收]],所以需要手动释放资源;否则泄漏的资源无法用于其他程序; <font color="red" >特别是c样式的C++程序bug的常见原因;</font>

### RALL机制
`resource acquisition is initialization` 意为 `资源获取即初始化` ;
核心是把资源和对象的生命周期绑定,对象创建获取资源,对象销毁释放资源;

#### 对象自动销毁
在 `C++` 的 [[development/C++/basic/Class]] 中有一个特殊的 <font color = red >清理函数 </font>: <font color = blue>析构函数 </font>;
析构函数与构造函数功能相反;


### 垃圾自动回收
>与托管语言不同，C++ 没有自动回收垃圾，这是在程序运行时释放堆
>内存和其他资源的一个内部进程。 C++ 程序负责将所有已获取的资源
>返回到操作系统。 未能释放未使用的资源称为“泄漏”。 在进程退出之
>前，泄漏的资源无法用于其他程序。

### 关于对象中的指针
1. **普通指针**：
    
    - 普通指针是一种直接存储内存地址的变量，它指向某个对象或数据。
    - 当对象被回收（例如，通过 `delete` 或 `free`）时，指针本身不会自动被回收。普通指针的生命周期不受对象的生命周期影响。
    - 如果你在回收对象后继续使用指针，那么它将成为“悬空指针”（dangling pointer），指向已经释放的内存区域，这是一种危险的行为。
2. **智能指针**：
    
    - 智能指针是 C++11 引入的一种机制，用于更安全地管理动态分配的内存。
    - 智能指针包括 `shared_ptr`、`unique_ptr` 和 `weak_ptr`。
    - `shared_ptr` 使用引用计数，当没有指针指向某个对象时，会自动释放对象的内存。因此，当对象被回收时，包含在 `shared_ptr` 中的指针也会被回收。
    - `unique_ptr` 是独占式智能指针，它确保一个时刻只有一个指针拥有所管理的对象。当 `unique_ptr` 超出作用域时，会自动释放内存。
3. **引用与指针**：
    
    - 引用是指针的另一种形式，但它没有自己的内存地址。引用必须在声明时初始化，并且一旦绑定到某个对象，就不能再改变。
    - 引用不需要手动释放内存，因为它只是对象的别名，不拥有内存

简而言之,在对象中使用的普通指针需要在析构函数中进行清除定义; `ptr = nullptr`